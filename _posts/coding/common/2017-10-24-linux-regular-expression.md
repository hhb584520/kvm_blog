# 正则表达式 #

## 例子 ##

1.2 去除头部两个字符(一个字符一个点，头部 '^')，尾部('$')三个字符
echo 0x12343000 | sed 's/^..x//g' | sed 's/...$//g'

## 查找文本 ##

用到的关键字 grep，最简单的用法就是使用固定字符串

比如使用who命令查找当前多少人登陆系统

who |grep syx，就可以查看名字叫 syx 的用户登录于何处。

grep 的语法：
grep [options pattern-spec [files...]

用途：显示匹配一个或者多个模式的文本行。时常为作为管道的第一步，以便对匹配的数据进一步处理。
主要选项

- -i：模式匹配时忽略大小写
- -V：显示不匹配的行
- -l：列出匹配模式的文件名称,而不是打印匹配的行
- -n：列出检索目标所在的行号
- -c：统计匹配的行总数,不显示航信息

## 行为模式 ##
当指名多个文件时，grep 会在每一行前面加上文件名与一个冒号。

- grep：最常用，可以检索目标（一个活多个单词或正则表达式）。
- fgrep：不能使用正则表达式，可以检索多个目标，等同于 grep -f
- egrep：支持丰富的正则表达式，而且支持多目标检索，等同于 grep -e。

从根本上来看，正则表达式是由两个基本组成部分所建立：一般字符与特殊字符。一般字符指的是任何没有特殊意义的字符。在某些情况下，特殊特殊字符也可以视为一般字符。特殊字符称为元字符（metacharacter）。

- BRE:基本正则表达式（Basic Regular Expression）
- ERE:扩展的正则表达式（Extended Regular Expression）

### 先来看一些简单的匹配 ###

- tolstoy：匹配一行上任意位置的 7 个字母：tolstoy
- ^tolstoy： 7 个字母 tolstoy，出现在一行的开头
- tolstoy$：出现在一行的结尾
- ^tolstoy$：正好包含这 7 个字母的一行，没有其他的任何字符。
- [tT]olstoy： 在一行的任意位居中，含有 Tolstoy 或者 tolstoy
- tol.toy：在一行的任意位居中，含有 tol 这三个字母，加上一个特殊字符，在接着 toy 这三个字母
- tol.*toy：在一行的任意位居中，含有 tol 这三个字母，加上任意的 0 或者多个字符，再继续 toy 这三个字母（例如：toltoy，tolstoy，tolWHOtoy 都是满足要求的）。

### shell 中的通配符 ###

- *： 代表 0 个或者多个任意字符
- ?： 代表一定有一个的任意字符
- []： 代表一定有一个在括号内的字符（非任意字符）。例如[abcd]代表一定有一个字符，可能是 abcd 这四个选项的任意一个。
- [-]：若有减号在括号内时，代表在编码顺序内的所有自负。例如：[0-9]代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的。
- [^]： 若括号内的第一个字符为指数字符(^)，那表示反向选择，例如：[^abc]代表一定有一个字符，只要是非 abc 的其他字符就可以。

### shell中的特殊字符 ###

- #：注释字符
- \：将特殊字符或者通配符还原成一般字符
- |：管道符，分割两个管线命令的界定
- ;：连续命令下达分隔符
- ~：用户的家目录
- $：放在变量前面，正确使用变量
- &：工作控制，将命令编程背景下工作
- !：非(!)的意思，逻辑运算符
- >,>>：输出重定向，分别是覆盖和追加
- <,<<：输入重定向
- ‘’：单引号，不具有变量置换的功能
- “”：双引号，具有变量置换的功能
- ()：在中间的为子 shell 的起始与结束
- {]：在中间为命令块的组合

### shell 中正则表达式的控制字符 ###

- ^：匹配行首位置
- $：匹配行尾位置
- .：匹配任意字符
- *：对*之前的匹配整体或字符匹配任意次（包括 0 次）
- \?：对\?之前的匹配整体或字符匹配 0 次或 1 次
- \{n\}: 对 \ { 之前的匹配整体或字符匹配 n 次
- \{m,\}: 对 \ { 之前的匹配整体或字符匹配至少 m 次
- \{m,n}: 对 \ { 之前的匹配整体或字符匹配 m 到 n 次
- [abcdef]: 对单字符而言匹配[]中的字符
- [a-z]： 对单字符而言，匹配任意一个小写字母
- [^a-z]：不匹配括号中的内容

## 基本正则表达式 ##

匹配单个字符

- 匹配一般字符：一般字符是指无特殊含义的字符，包括所有文本和数字字符，绝大多数的空白字符以及标点符号字符，因此，正则 a，匹配 a。

- 如果相匹配，因为是特殊字符，所以需要用 \ 转义，正则*，匹配*。

- .（点号）字符意即“任意字符”，例如a.c匹配于 abc，aac。

- 使用方括号表达式。例如x[abcdefg]z,可以匹配 xaz，xbz，等，方括号里如果存在(^)，表示取反的意思，就是说不匹配列表里的任意字符。

[0123456789]表示所数字，但是这样写太麻烦，我们可以用[0-9]来表示，[abcdefg]同样可以用[a-g]

## 单个表达式匹配多字符 ##

最简单的办法就是把它们一一列出来：正则 abc 匹配于 abc。  
虽然(.)meta 字符与方括号表达式都提供了依次匹配一个字符的很好方式，单正则真正强大而有力地功能是修饰符 meta 字符的使用上。 最常用的修饰符是()，表示匹配 0 个或多个前面的单个字符。因此 abc 表示“匹配一个 a,0 个或多个 b 字符以及 a 空 c ”。这个正则匹配的有 ac，abc，abbcabbbbc。
匹配 0 或多个，不表示匹配其他的某一个。例如正则 abc，文本 aQc 是不匹配的。但是 ac 是匹配的。
()修饰符虽然好用，但是他没有限制，如要只要指定次数，使用一个复杂的方括号表达式虽然也能指定次数，但是太过麻烦。我们就引入了区间表达式。所谓的区间表达式有三种变化
\{n\} 前置正则表达式所得结果重现 n 次
\{n,\} 前置正则表达式所得结果至少出现 n 次
\{n,m\} 出现 n 到 m 次
例如我们想要表达“重现 5 个 a” =>a\{5\}，“重现 10 到 42 个 q ” =>q\{10,42\}；

    `# grep "[abc]\{3\}" -r tst`
     abcabbc

## 文本匹配锚点 ##

两个 meta 字符是脱节符号(^)，与货币字符(&)，他们叫做锚点，因为其用途在限制正则表达式匹配时，针对要被匹配字符的开始或者结尾处进行匹配，  
假定有一串字符串：abcABCdefDEF  
正则表达式锚点的范例

    模式	          是否匹配	    理由
    ABC	            是	        居中的 4，5，6字符匹配
    ^ABC	        否	        起始处不是ABC
    def	            是	        居中的 7，8，9 字符匹配
    def$	        否	        结尾处不是 def
    [[:upper:]]{3}	是	        居中的大写 ABC 匹配
    [[:upper:]]{3}$	是	        结尾的大写 DEF 匹配
    ^[[:alpha:]]{3}	是	        起始处的 abc 匹配

^和$当然能同时使用，这种情况将括起来的正则表达式匹配整个字符串（或行）。有时^$这样简易的正则很好用，可以用来匹配空的字符串或行列。例如加上 grep -v 选项用来显示所有不匹配模式的行们使用上面的做法，便能过滤掉文件里的空号。
^$尽在起始与结尾具有特殊用处。例如 ab^cd 里的^表示的就是自身(^)。

## 交替 ##
方括号运算符一宇表示“匹配于次祖父，或其他字符，或...”，但不能指定“ 匹配于这个序列，或其他序列”。要达到后者的目的，可以使用管道运算符 ( | )。例如read | write匹配于 read 与 write 两者，fast|slow匹配于 fast 与 slow。
| 字符是 ERE 运算符；i 优先级最低的。




基本语法[编辑]

一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。例如：Handel、Händel和Haendel这三个字符串，都可以由“H(a|ä|ae)ndel”这个模式来描述。大部分正则表达式的形式都有如下的结构：
选择|竖线符代表选择（即并集），具有最低优先级。例如“gray|grey”可以匹配grey或gray。数量限定某个字符后的数量限定符用来限定前面这个字符允许出现的个数。最常见的数量限定符包括“+”、“?”和“*”（不加数量限定则代表出现一次且仅出现一次）：+加号代表前面的字符必须至少出现一次。（1次、或多次）。例如，“goo+gle”可以匹配google、gooogle、goooogle等;?问号代表前面的字符最多只可以出现一次。（0次、或1次）。例如，“colou?r”可以匹配color或者colour;*星号代表前面的字符可以不出现，也可以出现一次或者多次。（0次、或1次、或多次）。例如，“0*42”可以匹配42、042、0042、00042等。匹配圆括号可以用来定义操作符的范围和优先度。例如，“gr(a|e)y”等价于“gray|grey”，“(grand)?father”匹配father和grandfather。
上述这些构造子都可以自由组合，因此，“H(ae?|ä)ndel”和“H(a|ae|ä)ndel”是相同的。

精确的语法可能因不同的工具或程序而异。

PCRE表达式全集[编辑]

正则表达式有多种不同的风格。下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表，适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）：


字符

描述


\
将下一个字符标记为一个特殊字符(File Format Escape，清单见本表)、或一个原义字符（Identity Escape，有^$()*+?.[\{|共计12个)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。 

^
匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 

$
匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 

*
匹配前面的子表达式零次或多次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}。 

+
匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 

?
匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 

{n}
n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 

{n,}
n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 

{n,m}
m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 

?
非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 

.
匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。 

(pattern)
匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 

(?:pattern)
匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 

(?=pattern)
正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 

(?!pattern)
正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 

(?<=pattern)
反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 

(?<!pattern)
反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 

x|y
匹配x或y。例如，“z|food”能匹配“z”或“food”。“(?:z|f)ood”则匹配“zood”或“food”。 

[xyz]
字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位（或末尾）则仅作为普通字符。右方括号应转义出现，也可以作为首位字符出现。 

[^xyz]
排除型字符集合（negated character classes）。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 

[a-z]
字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 

[^a-z]
排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 

[:name:]
增加命名字符类（named character class）[注 1]中的字符到表达式。只能用于方括号表达式。 

[=elt=]
增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用于方括号表达式。 

[.elt.]
增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语， "CH"作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。 

\b
匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 

\B
匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 

\cx
匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 

\d
匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符。 

\D
匹配一个非数字字符。等价于[^0-9]。 

\f
匹配一个换页符。等价于\x0c和\cL。 

\n
匹配一个换行符。等价于\x0a和\cJ。 

\r
匹配一个回车符。等价于\x0d和\cM。 

\s
匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。注意Unicode正则表达式会匹配全角空格符。 

\S
匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 

\t
匹配一个制表符。等价于\x09和\cI。 

\v
匹配一个垂直制表符。等价于\x0b和\cK。 

\w
匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符。 

\W
匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 

\ck
匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法。 

\xnn
十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。. 

\num
向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符。 

\n
标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 

\nm
3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 

\nml
如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 

\un
Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 

Unicode处理[编辑]

在.NET、Java、JavaScript、Python的正则表达式中，可以用\uXXXX表示一个Unicode字符，其中XXXX为四位16进制数字。

Unicode字符的三种性质：[1]
Unicode Property：字符属于标点、空格、字母等等。每个Unicode字符只能属于唯一Unicode Property。.NET、Java、PHP和Ruby等语言支持。具体分类为： 字符\p{L} \p{Ll}或\p{Lowercase_Letter}：小写字符（必须有大写的形式）
\p{Lu}或\p{Uppercase_Letter}: 大写字符（必须有小写的形式）
\p{Lt}或\p{Titlecase_Letter}: 全词首字母大写的字符
\p{L&}或\p{Cased_Letter}: 存在大小写形式的字符(Ll, Lu, Lt的组合)
\p{Lm}或\p{Modifier_Letter}: 音标修饰字符
\p{Lo}或\p{Other_Letter}: 不具有大小写的字符或字形

附加符号\p{M} \p{Mn}或\p{Non_Spacing_Mark}: 与其他字符结合，不额外占用空间的字符，例如日耳曼语元音变音
\p{Mc}或\p{Spacing_Combining_Mark}: 与其他字符结合，不额外占用空间的字符，例如马拉雅拉姆文#元音字母及附标
\p{Me}或\p{Enclosing_Mark}: 包含其他字符的字符，例如圆圈、方块、

分隔符p{Z} \p{Zs}或\p{Space_Separator}: a whitespace character that is invisible, but does take up space.
\p{Zl}或\p{Line_Separator}: line separator character U+2028.
\p{Zp}或\p{Paragraph_Separator}: paragraph separator character U+2029

符号\p{S} \p{Sm}或\p{Math_Symbol}: 数学符号
\p{Sc}或\p{Currency_Symbol}: 通货符号
\p{Sk}或\p{Modifier_Symbol}: 组合为其他字符的符号
\p{So}或\p{Other_Symbol}: 其他符号

数值字符\p{N} \p{Nd}或\p{Decimal_Digit_Number}: 所有文本中的数字0至9字符，不含形意符号
\p{Nl}或\p{Letter_Number}: 看起来像字母的符号，包含罗马数字
\p{No}或\p{Other_Number}: 上角标或下角标数字，或者其他不属于0至9的数字。不含形意符号

标点符号\p{P} \p{Pd}或\p{Dash_Punctuation}: 任何种类的连字号或连接号
\p{Ps}或\p{Open_Punctuation}: 任何种类开括号
\p{Pe}或\p{Close_Punctuation}: 任何种类闭括号
\p{Pi}或\p{Initial_Punctuation}: 任何种类开引号
\p{Pf}或\p{Final_Punctuation}: 任何种类闭引号
\p{Pc}或\p{Connector_Punctuation}: 连接词的标点符号，如下划线
\p{Po}或\p{Other_Punctuation}: 其他标点符号

其它符号\p{C}（包括不可见控制字符与未用码位） \p{Cc}或\p{Control}: ASCII或Latin-1控制字符0x00–0x1F与0x7F–0x9F.
\p{Cf}或\p{Format}: 不可见的格式化指示字符
\p{Co}或\p{Private_Use}: 私用码位
\p{Cs}或\p{Surrogate}: UTF-16编码的代理对的一半
\p{Cn}或\p{Unassigned}: 未被使用的码位


Unicode Block：按照编码区间划分Unicode字符，每个Unicode Block中的字符编码属于一个编码区间。例如Java语言\p{ InCJK_Compatibility_Ideographs }，.NET语言\p{ IsCJK_Compatibility_Ideographs }
Unicode Script：按照字符所属的书写系统来划分Unicode字符。PHP和Ruby（版本不低于1.9）支持Unicode Script。例如\p{Han}表示汉语（中文字符）。

这三种Unicode性质对应的字符组补集是将开头的\p改为\P，其它不变。

POSIX字符组[编辑]


POSIX字符组

说明

ASCII环境

Unicode环境

[:alnum:] 字母字符和数字字符 [a-zA-Z0-9] [\p{L&}\p{Nd}] 
[:alpha:] 字母 [a-zA-Z] \p{L&} 
[:ascii:] ASCII字符 [\x00-\x7F] \p{InBasicLatin} 
[:blank:] 空格字符和制表符 [ \t] [\p{Zs}\t] 
[:cntrl:] 控制字符 [\x00-\x1F\x7F] \p{Cc} 
[:digit:] 数字字符 [0-9] \p{Nd} 
[:graph:] 空白字符之外的字符 [\x21-\x7E] [^\p{Z}\p{C}] 
[:lower:] 小写字母字符 [a-z] \p{Ll} 
[:print:] 类似[:graph:]，但包括空白字符 [\x20-\x7E] \P{C} 
[:punct:] 标点符号 }~-] [\p{P}\p{S}] 
[:space:] 空白字符 [ \t\r\n\v\f] [\p{Z}\t\r\n\v\f] 
[:upper:] 大写字母字符 [A-Z] \p{Lu} 
[:word:] 字母字符 [A-Za-z0-9_] [\p{L}\p{N}\p{Pc}] 
[:xdigit:] 十六进制字符 [A-Fa-f0-9] [A-Fa-f0-9] 

优先权[编辑]


 优先权

符号

最高 \ 
高 ( )、(?: )、(?= )、[ ] 
中 *、+、?、{n}、{n,}、{m,n} 
低 ^、$、中介字符 
次最低 串接，即相邻字符连接在一起 
最低 | 


## Ref ##

http://blog.csdn.net/fdl19881/article/details/7800877

https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F