# Perf 综合分析工具介绍

## 1. 性能工具详细介绍

[Linux_Performance_Analysis_and_Tools.pdf](/kvm_blog/files/perf/Linux_Performance_Analysis_and_Tools.pdf)

[Linux_Performance_and_Tunning_guildlines.pdf](/kvm_blog/files/perf/Linux_Performance_and_Tunning_guildlines.pdf)

性能分析是一个综合东西非常复杂，从模块来分可以分为应用、系统库、系统调用、文件系统、网络、调度、内存，从层次来分有可以分为 用户层、系统层、虚拟化层。

解决一个性能瓶颈，往往又会出现论文的瓶颈或者其他问题，所以性能优化更加切实的目标是做到在一定范围内使系统的各项资源使用趋向合理和保持一定的平衡。系统运行良好的时候恰恰也是各项资源达到了一个平衡体，任何一项资源的过渡使用都会造成平衡体系破坏，从而造成系统负载极高或者响应迟缓。比如CPU 过度使用会造成大量进程等待 CPU 资源，系统响应变慢，等待会造成进程数增加，进程增加又会造成内存使用增加，内存耗尽又会造成虚拟内存使用，使用虚拟内存又会造成磁盘 IO 增加和CPU开销增加（用于进程切换、缺页处理的 CPU 开销）

### 1.1 延时

	    DDR2   5473MB/s  86.7ns
	    DDR3   6965MB/s  81.8ns
	    L1: 大小  32K， 访存时间 4cycle
	    L2: 大小 256K， 访存时间 12cycle
	    L3: 大小 20M,   访存时间 26-31cycle
	    Memory: 180cycle
	    内存带宽:每秒中 CPU 可以从内存读取的数据量。内存带宽理论值为 内存通道数 * 内存实际运行频率 * 位宽/8，以Intel Xeon 5500/5600系统为例，内存带宽最大值= 6*1333*8=60GB/s，实测数据是理论数据的50%-60%。
	    PCIe: 8GB/s， 每加一级加 200ns
	    SSD Disk: 10us-1ms, 50MB~2GB/s
	    机械 Disk: 5-20ms, 50~200MB/s
	    网卡：100us~1ms, 10MB~10GB/s

## 2. 综合分析工具
### 2.1 dstat
#### 2.1.1 dstat 介绍
dstat 是一个可以取代vmstat，iostat，netstat和ifstat这些命令的多功能产品。dstat克服了这些命令的局限并增加了一些另外的功能，增加了监控项，也变得更灵活了。dstat可以很方便监控系统运行状况并用于基准测试和排除故障。

dstat可以让你实时地看到所有系统资源，例如，你能够通过统计IDE控制器当前状态来比较磁盘利用率，或者直接通过网络带宽数值来比较磁盘的吞吐率（在相同的时间间隔内）。

dstat将以列表的形式为你提供选项信息并清晰地告诉你是在何种幅度和单位显示输出。这样更好地避免了信息混乱和误报。更重要的是，它可以让你更容易编写插件来收集你想要的数据信息，以从未有过的方式进行扩展。

Dstat的默认输出是专门为人们实时查看而设计的，不过你也可以将详细信息通过CSV输出到一个文件，并导入到Gnumeric或者Excel生成表格中。

#### 2.1.2 各列说明

	[root@hhb-kvm netperf-2.7.0]# dstat
	----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
	usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw
	  0   0 100   0   0   0|  12k 4872B|   0     0 |   0     0 |  35    70
	  0   0 100   0   0   0|   0     0 | 595B  460B|   0     0 |  53   100
	  0   0 100   0   0   0|   0     0 | 198B  134B|   0     0 |  44    76
	  0   0 100   0   0   0|   0     0 | 394B  110B|   0     0 |  50    80
	  0   0 100   0   0   0|   0     0 | 648B  110B|   0     0 |  43    89
	  0   0 100   0   0   0|   0     0 | 712B  110B|   0     0 |  64   104
	  0   0 100   0   0   0|   0     0 | 320B  110B|   0     0 |  43    68
	  0   0 100   0   0   0|   0     0 | 953k   18k|   0     0 | 377   602
	  0   0 100   0   0   0|   0     0 |1234k   20k|   0     0 | 470   754
	  0   0 100   0   0   0|   0     0 |2095k   35k|   0     0 | 696  1230
	  0   0 100   0   0   0|   0     0 |2188k   37k|   0     0 | 702  1226
	  0   0  99   0   0   0|   0     0 |2793k   47k|   0     0 | 858  1529
	  0   0 100   0   0   0|   0     0 |3844k   65k|   0     0 |1128  2092
	  0   1  99   0   0   0|   0     0 |4553k   78k|   0     0 |1338  2471

- CPU状态：CPU的使用率。这项报告更有趣的部分是显示了用户，系统和空闲部分，这更好地分析了CPU当前的使用状况。如果你看到"wait"一栏中，CPU的状态是一个高使用率值，那说明系统存在一些其它问题。当CPU的状态处在"waits"时，那是因为它正在等待I/O设备（例如内存，磁盘或者网络）的响应而且还没有收到。

- 磁盘统计：磁盘的读写操作，这一栏显示磁盘的读、写总数。

- 网络统计：网络设备发送和接受的数据，这一栏显示的网络收、发数据总数。

- 分页统计：系统的分页活动。分页指的是一种内存管理技术用于查找系统场景，一个较大的分页表明系统正在使用大量的交换空间，或者说内存非常分散，大多数情况下你都希望看到page in（换入）和page out（换出）的值是0 0。

- 系统统计：这一项显示的是中断（int）和上下文切换（csw）。这项统计仅在有比较基线时才有意义。这一栏中较高的统计值通常表示大量的进程造成拥塞，需要对CPU进行关注。你的服务器一般情况下都会运行运行一些程序，所以这项总是显示一些数值。

#### 2.1.3 常用命令介绍

dstat可以通过传递2个参数运行来控制报告间隔和报告数量。例如，如果你想要dstat输出默认监控、报表输出的时间间隔为3秒钟,并且报表中输出10个结果，你可以运行如下命令：

	dstat 3 10

查看全部内存都有谁在占用：

	dstat -g -l -m -s --top-mem

显示一些关于CPU资源损耗的数据：

	dstat -c -y -l --proc-count --top-cpu

如何输出一个csv文件
想输出一个csv格式的文件用于以后，可以通过下面的命令：

	$ dstat –output /tmp/sampleoutput.csv -cdn

### 2.2 top

**cpu list**

技巧：运行 top 时，按「1」打开 CPU 列表，按「shift+p」以 CPU 排序。

**top 修改nice**

    $ top—>r —>PID—>nice值

**highlight**

    $ top-> b/y		
		$ top-> x/x

**change sort line**

		$ top -> shift + >/<   //left and right

**change display line**

		$ top -> f

**param explain**

		Process stutus: R=Run, S=Sleep, T=Tracing/Stop, D=No Interrupt Sleep, Z=zombie
		TIME+: Process use cpu time: 1/100 second.

第一行：

 13:42:59 当前系统时间
 6 days, 9:29 系统已经运行了6天6小时29分钟（在这期间没有重启过）
 3 users 当前有3个用户登录系统
 load average: 3.06,3.01, 1.79 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

第二行：
 Tasks 任务（进程），系统现在共有131个进程，其中处于运行中的有3个，127个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。

第三行：cpu状态
 10.6% us 用户空间占用CPU的百分比。
 2.2% sy 内核空间占用CPU的百分比。
 0.0% ni 改变过优先级的进程占用CPU的百分比
 84.5% id 空闲CPU百分比
 2.5% wa IO等待占用CPU的百分比
 0.1% hi 硬中断（Hardware IRQ）占用CPU的百分比
 0.0% si 软中断（Software Interrupts）占用CPU的百分比
在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。

第四行：内存状态
 8300124k total 物理内存总量（8GB）
 5979476k used 使用中的内存总量（5.7GB）
 2320648k free 空闲内存总量（2.2G）
 455544k buffers 缓存的内存量 （434M）

第五行：swap交换分区
8193108k total 交换区总量（8GB）SL
 41568k used 使用的交换区总量（40.6M）
 8151540k free 空闲交换区总量（8GB）
 4217456k cached 缓冲的交换区总量（4GB）
这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器危矣：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。
第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。
如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存： 2320648+455544 +4217456 = 6.6GB。
对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。


top命令的补充
top命令是Linux上进行系统监控的首选命令，但有时候却达不到我们的要求，top命令的监控最小单位是进程，所以看不到程序的线程数和客户连接数，通常可以ps和netstate两个命令来补充top的不足。
监控java线程数：
 ps -eLf | grep java | wc -l
监控网络客户连接数：
 netstat -n | grep tcp | grep 侦听端口 | wc -l
上面两个命令，可改动grep的参数，来达到更细致的监控要求。
在Linux系统一切都是文件的思想贯彻指导下，所有进程的运行状态都可以用文件来获取。系统根目录/proc中，每一个数字子目录的名字都是运行中的进程的PID，进入任一个进程目录，可通过其中文件或目录来观察进程的各项运行指标，例如task目录就是用来描述进程中线程的，因此也可以通过下面的方法获取某进程中运行中的线程数量（PID指的是进程ID）：
ls /proc/PID/task | wc -l
在linux中还有一个命令pmap，来输出进程内存的状况，可以用来分析线程堆栈：pmap PID


### 2.3 htop

	$ yum install htop

# 3. 各种评测工具
	|---------------------------------------------------------|
	|          Applications, DBs, all server types, ...       |
	|              -------------------------------------------|
	|              |   System Libraries                       |
	|---------------------------------------------------------|
	|                System Call Interface                    |
	|---------------------------------------------------------|
	|          VFS            |   Sockets    |                |         +------+
	|-------------------------|--------------|    Scheduler   |---------|  CPU |
	|  ext4/... |             |   TCP/UDP    |                |         +------+
    |-----------|    ZFS      |--------------|----------------|            |
	|  LVM      |             |    IP        |                |            |
	|-------------------------|--------------| Virtual Memory |         +------+
	| Block Device Interface  |  Ethernet    |                |         | DRAM |
	|---------------------------------------------------------|         +------+
	|                     Device Drivers                      |
	|---------------------------------------------------------|
							  |
	                    +------------+
						| I/O Bridge |
                        +------------+
                              |
                 ----------------------------------------
				  |                                   |
	        +----------------+               +--------------------+
			| I/O Controller |               | Network Controller |
            +----------------+               +--------------------+
			   |          |                      |             |
            +------+   +------+              +------+      +------+
		    | Disk |   | Disk |              | Port |      | Port |
            +------+   +------+              +------+      +------+





## 3.1  System Call Interface
   strace

   http://lzz5235.github.io/2013/11/22/ltrace-strace-ftrace.html

## 3.2 sysstat

   wget http://pagesperso-orange.fr/sebastien.godard/sysstat-11.0.0.tar.gz
   cd sysstat-11.0.0/
   ./configure
   make
   make install

# 4. 综合评测工具

dstat -cdlmnpsy

https://linux.cn/article-3215-1.html

# ref
https://coolshell.cn/articles/7490.html
